module MP where

import System.Environment

type FileContents = String

type Keyword      = String
type KeywordValue = String
type KeywordDefs  = [(Keyword, KeywordValue)]

separators :: String
separators
  = " \n\t.,:;!\"\'()<>/\\"


lookUp :: String -> [(String, a)] -> [a]
-- Returns the list of items whose associated string matches the search string
lookUp a list = [y | (x, y) <- list, x == a]

putwd :: [Char] -> String -> String
-- a helper function that build a word letter by letter
putwd a (t : ts)
 | not (elem t a) = t : putwd a ts
 | otherwise = []
putwd a [] = []

pstn :: [Char] -> String -> String
-- a helper function that finds the position of the string after we put the word
-- in the list
pstn a (t : ts)
 | not (elem t a) = pstn a ts
 | otherwise = t : ts
pstn a [] = []

split :: [Char] -> String -> (String, [String])
-- a function that splits a string in a tuples that contains as a first argument
-- the list o separators in order that appear in the string and a list of the
-- words from the string (original version)
split _ "" = ("",[""])
split s t
 | elem (head t) s = (splitsep s t, "" : splitwords s t)
 | otherwise = (splitsep s t, splitwords s t)
 where
 splitsep :: [Char] -> String -> String
 -- build the string of the separators
 splitsep x (y : ys)
  | elem y x = y : splitsep x ys
  | otherwise = splitsep x ys

 splitsep x [] = []
 splitwords :: [Char] -> String -> [String]
 -- build the list of the words from a given string
 splitwords a [] = []
 splitwords a (z1 : (z2 : zs))
  | elem z1 a && elem z2 a = "" : splitwords a (z2 : zs)
  -- if both of the characters are separators adds an empty list
  | elem z1 a = splitwords a (z2 : zs) ++ []
  | otherwise = putwd a (z1 : (z2 : zs)) : splitwords a (pstn a (z1 : (z2 : zs)))
 splitwords a (z1 : zs)
  | elem z1 a = splitwords a zs ++ [""]
  | otherwise = putwd a (z1 : zs) : splitwords a zs

split2 :: [Char] -> String -> (String, [String])
-- A shorter implementation of function split
split2 x [] = ("",[""])
split2 x (y : ys)
  | elem y x = (y : m, "" : (p : n))
  | otherwise = (m, (y : p) : n)
  where
  (m, (p : n)) = split2 x ys

combine :: String -> [String] -> [String]
-- combine the components of a string from its constituent separator characters
-- and words, as generated by a call to function split
combine "" y = y
combine (x : xs) [""] = [x] : combine xs [""]
combine (x : xs) (y : ys) = y : [x] : combine xs ys

getKeywordDefs :: [String] -> KeywordDefs
-- takes the contents of an information file in the form of a list of lines
-- and which returns a list of keyword/definition pairs
getKeywordDefs (x : xs) = (aux x) : getKeywordDefs xs
getKeywordDefs [] = []

aux :: String -> (Keyword, KeywordValue)
aux (y : ys)
 | y /= ' ' = (y : (fst (aux ys)), snd (aux ys))
 | otherwise = ([], ys)
aux [] = ([], [])

expand :: FileContents -> FileContents -> FileContents
-- takes the contents of a text file and an info file and combines them using
-- the above functions to build a string representing the output file
expand x y
 = replaceWord (combine (fst s) (snd s)) (getKeywordDefs (snd (split2 "\n" y)))
 where
 s = split2 separators x
 replaceWord :: [String] -> KeywordDefs -> String
 -- helper function that replace each word with its definition
 replaceWord [] k = []
 replaceWord (n : ns) [] = n ++ (replaceWord ns [])
 replaceWord (n : ns) k
  | n == [] = replaceWord ns k
  | head n == '$' = (head (lookUp n k)) ++ (replaceWord ns k)
  | otherwise = n ++ (replaceWord ns k)


expand2 :: FileContents -> FileContents -> FileContents
-- another implementation of expand function so that it expands the input file
-- once for each set of definitions.
expand2 x [] = []
expand2 x y = aux x (snd (split2 "#" y))
 where
 aux :: FileContents -> [String] -> String
 aux a [] = []
 aux a (b : bs) = (expand a b) ++ "-----\n" ++ (aux a bs)

-- You may wish to uncomment and implement this helper function
-- when implementing expand
-- replaceWord :: String -> KeywordDefs -> String


main :: IO ()
-- The provided main program which uses your functions to merge a
-- template and source file.
main = do
  args <- getArgs
  main' args

  where
    main' :: [String] -> IO ()
    main' [template, source, output] = do
      t <- readFile template
      i <- readFile source
      writeFile output (expand2 t i)
    main' _ = putStrLn ("Usage: runghc MP <template> <info> <output>")

